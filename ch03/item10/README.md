# CH 3. 모든 객체의 공통 메서드

# 아이템10: equals는 일반 규약을 지켜 재정의하라

## Q1. equals 재정의 할 때, 일반규약을 지키지 않으면 무슨 문제가 발생하는가?

→ equals 메서드를 재정의한 클래스의 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수가 없다.

### equals 메서드를 재정의 하지 않는 경우

- 각 인스턴스가 본질적으로 고유하다: 값을 표현하는 것이 아닌 동작하는 개체를 표현하는 클래스 ex.Thread
- 인스턴스의 논리적 동치성을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.
- 값 클래스 중 값이 같은 인스턴스가 2개 이상 만들어지지 않음을 보장하는 클래스 ex.Enum

### equals 메서드를 재정의 해야 하는 경우

- 두 객체가 물리적으로 같은가(객체 식별성)를 비교하는 것이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 이를 비교할 수 있도록 재정의 되어 있지 않은 경우 → **주로 값 클래스**

### equals 메서드 재정의 일반규약

- **반사성(reflexivity)**: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.
  - 객체는 자기 자신과 같아야 한다는 뜻
- **대칭성(symmetry)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true
  - 두 객체는 서로에 대한 동치 여부가 같아야 한다는 뜻
- **추이성(transitivity)**: null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고, y.equals(z)도 true면, x.equals(z)도 true다.
  - 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다는 뜻
- **일관성(consistency)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
  - 일관성은 두 객체가 같다면 수정되지 않는 한 앞으로도 영원히 같아야 한다는 뜻이다.
  - **클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들면 안된다./**
- **null-아님**: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.
  - 모든 객체가 null과 가지 않아야 한다는 듯

### equals 메서드 재정의

1.  `==` 연산자를 사용해 입력이 자기 자신의 참조인지 확인
2.  `instanceof` 연산자로 입력이 올바른 타입인지 확인
3.  입력을 올바른 타입으로 형 변환
4.  입력 객체와 자기 자신의 대응되는 **핵심** 필드들이 모두 일치하는지 하나씩 검사

<aside>
💡 equals를 재정의 할 땐 hashCode도 반드시 재정의 하자! <br>
💡 꼭 필요한 경우가 아니라면 equals를 재정의 하지 말자!
</aside>
